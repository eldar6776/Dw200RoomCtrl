//build:20240724
/**
 * Basic components of UI, you need to understand some concepts first
 * 1. Layers: device has 2 basic layers, main layer (main) and top layer (top)
      其中TOP图层永远在主图层之上，主图层切换页面不会挡住TOP图层，TOP图层用于显示一些状态栏是比较合适的。
      其中主图层可以预先在内存中构造多个页面，然后通过loadMain来加载切换不同的页面。而TOP图层不能切换，只能让ui对象隐藏或删除

 * 2. UI objects: There are many types of UI objects, the most basic of which is the 'view' object. The root ui objects of the main layer and the top layer must be the 'view' object, and the remaining ui objects are all sub-uis of a certain ui object.
      ui对象包括常见的 'button'、'label'、'image'等等，所有对象都有一些通用的属性，也有一些独特的属性
      所有 ui 对象都有全局唯一的 id ，不能重复。通用的属性还包括
      - type：获取ui对象的类型，字符串
      - parent：获取ui对象的父节点，字符串
      - children：获取ui对象的所有子对象的id，字符串数组

 * 3. dxui file: A file with the extension .dxui is a ui tree generated by using a visual drag and drop tool. The tool will automatically generate the corresponding js file, and you can import the corresponding js file to operate.

 */

import logger from './dxLogger.js'
import utils from './uiUtils.js'
import button from './uiButton.js'
import font from './uiFont.js'
import image from './uiImage.js'
import label from './uiLabel.js'
import line from './uiLine.js'
import list from './uiList.js'
import dropdown from './uiDropdown.js'
import checkbox from './uiCheckbox.js'
import slider from './uiSlider.js'
import _switch from './uiSwitch.js'
import textarea from './uiTextarea.js'
import keyboard from './uiKeyboard.js'
import style from './uiStyle.js'
import view from './uiView.js'
import buttons from './uiButtons.js'

const dxui = {}
dxui.Button = button
dxui.Font = font
dxui.Image = image
dxui.Label = label
dxui.Line = line
dxui.List = list
dxui.Dropdown = dropdown
dxui.Checkbox = checkbox
dxui.Slider = slider
dxui.Switch = _switch
dxui.Textarea = textarea
dxui.Keyboard = keyboard
dxui.Style = style
dxui.View = view
dxui.Utils = utils
dxui.Buttons = buttons
let orientation = 1 //默认横屏
/**
 * initialize, must be called at the front of the code
 *  @param {object} options initializeparameter
 * @param {number} options.orientation Screen orientation can be 0, 1, 2, 3, which respectively means vertical screen, the screen is on the left; horizontal screen, the screen is on the top; vertical screen, the screen is on the right; horizontal screen, the screen is on the bottom
 * @param {object} context context. Each application has a unique context variable. Different js can reference dxUi.js, but the context must be consistent.
*/
dxui.init = function (options, context = {}) {
     this.initContext(context)
     if (options && options.orientation != undefined && options.orientation != null && [0, 1, 2, 3].includes(options.orientation)) {
          orientation = options.orientation
     }
     utils.GG.NativeDisp.lvDispSetRotation(orientation)
}
/**
 * initialize context. Each application has a unique context variable. Different js can reference dxUi.js, but the context must be consistent.
 * Need to initialize before building ui
 * @param {object} context is initially an empty object{}
 */
dxui.initContext = function (context) {
     utils.validateObject(context)
     dxui.all = context
     dxui.Button.all = dxui.all
     dxui.Image.all = dxui.all
     dxui.Label.all = dxui.all
     dxui.Line.all = dxui.all
     dxui.List.all = dxui.all
     dxui.Dropdown.all = dxui.all
     dxui.Checkbox.all = dxui.all
     dxui.Slider.all = dxui.all
     dxui.Switch.all = dxui.all
     dxui.Textarea.all = dxui.all
     dxui.Keyboard.all = dxui.all
     dxui.View.all = dxui.all
     dxui.Buttons.all = dxui.all
}
/**
 * ui object that has been built based on widget/obtain
 * @param {string} id 
 * @returns 
 */
dxui.getUi = function (id) {
     return dxui.all[id]
}
/**
 * The outer loop needs to call this method
 */
dxui.handler = function () {
     return utils.GG.NativeTimer.lvTimerHandler()
}
/**
 * get/obtain screen direction. Different screen directions may require loading different UI or different processing logic.
 * @returns can be 0, 1, 2, 3, respectively indicating vertical screen, the screen is on the left; horizontal screen, the screen is on the top; vertical screen, the screen is on the right; horizontal screen, the screen is on the bottom
 */
dxui.getOrientation = function () {
     return orientation;
}
/**
 * Create a timer and execute a callback function every ms. It is mainly used to refresh the value of a certain UI object regularly.
 * You can delete the timer (clearInterval) in the callback function to achieve the effect of setTimeout
 * @param {string} id unique identifier of the timer required
 * @param {function} callback callback function (can be an anonymous function)
 * @param {number} ms milliseconds
 * @param {object} user_data user data, passed to the callback parameter
 * @returns timer handle
 */
dxui.setInterval = function (id, callback, ms, user_data) {
     if (utils.validateId(dxui.all, id))
          if (!callback || (typeof callback != 'function') || !callback.name || callback.name === '') {
               throw new Error('The callback should not be null and should be named function')
          }
     if (!ms || (typeof ms != 'number')) {
          throw new Error('The interval should not be empty, and should be number')
     }
     if (!this.all.__interval) {
          this.all.__interval = {}
     }
     this.all.__interval[id] = utils.GG.NativeTimer.lvTimerCreate(callback, ms, user_data)
}
/**
 * You can delete the timer when it is no longer needed.
 * @param {string} id timer id
 */
dxui.clearInterval = function (id) {
     if (!dxui.all[id]) {
          return
     }
     utils.GG.NativeTimer.lvTimerDel(dxui.all[id])
     delete dxui.all.__interval[id]
}
/**
 * get/obtainui object's parent object
 * @param {Object} ui 
 */
dxui.getParent = function (ui) {
     if (ui.parent) {
          return dxui.getUi(ui.parent)
     }
     return null
}
/**
 * Delete the current own ui object
 */
dxui.del = function (ui) {
     function recursiveDelete(ui) {
          // If the object does not exist, return directly
          if (!dxui.all[ui.id]) {
               return;
          }

          // First delete all child objects recursively
          if (ui.children && Array.isArray(ui.children)) {
               // Traverse child nodes in reverse order
               for (let i = ui.children.length - 1; i >= 0; i--) {
                    const childId = ui.children[i];
                    if (dxui.all[childId]) {
                         recursiveDelete(dxui.all[childId]);
                    }
               }
          }
          // Remove the current object from its parent object
          if (ui.parent && dxui.all[ui.parent] && Array.isArray(dxui.all[ui.parent].children)) {
               const children = dxui.all[ui.parent].children
               let index = children.indexOf(ui.id);
               if (index !== -1) {
                    children.splice(index, 1);
               }
          }

          // Delete current object
          ui.obj.lvObjDel();
          delete dxui.all[ui.id];
     }

     // Start recursive deletion
     recursiveDelete(ui);
}
/**
 * Load (switch) the already constructed ui object on the main layer,
 * @param {object} ui ui object built using buildfunction
 */
dxui.loadMain = function (ui) {
     if (!ui || !ui.obj) {
          throw new Error("dxui.loadMain:'ui' paramter should not be null")
     }
     // Loading home screen
     utils.GG.NativeDisp.lvScrLoad(ui.obj)
}
/**
 * The time elapsed since the last display of user activity (such as a click)
 * @returns Returns the elapsed time (milliseconds) since the last activity
 */
dxui.getIdleDuration = function () {
     return utils.GG.NativeDisp.lvDispGetInactiveTime()
}
/**
 * Reset elapsed time displayed for user activity (such as clicks)
 */
dxui.trigActivity = function () {
     utils.GG.NativeDisp.lvDispTrigActivity()
}

export default dxui;